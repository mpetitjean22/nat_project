package process_packet

import (
	"testing"

	"github.com/google/gopacket"
	"github.com/google/gopacket/layers"
)

func createGoPacket(data []byte) gopacket.Packet {
	return gopacket.NewPacket(data, layers.LayerTypeEthernet, gopacket.Default)
}

func getGoPacketValues(packet gopacket.Packet, t *testing.T) (ethType uint16, srcIP [4]byte, dstIP [4]byte, srcPort [2]byte, dstPort [2]byte) {
	ethernetLayer := packet.Layer(layers.LayerTypeEthernet)
	if ethernetLayer == nil {
		t.Errorf("No Ethernet Type")
	}
	ethernet, _ := ethernetLayer.(*layers.Ethernet)
	ethType = uint16(ethernet.EthernetType)

	ip4Layer := packet.Layer(layers.LayerTypeIPv4)
	// ip6Layer := packet.Layer(layers.LayerTypeIPv6)

	if ip4Layer != nil {
		ip, _ := ip4Layer.(*layers.IPv4)
		copy(srcIP[:], ip.SrcIP)
		copy(dstIP[:], ip.DstIP)
	} else {
		t.Errorf("Not IPv4")
	}
	/* Revisit IPv6!
	else if ip6Layer != nil {
		ip, _ := ip6Layer.(*layers.IPv6)
		srcIP = ip.SrcIP
		dstIP = ip.DstIP
	}
	*/

	tcpLayer := packet.Layer(layers.LayerTypeTCP)
	udpLayer := packet.Layer(layers.LayerTypeUDP)
	if tcpLayer != nil {
		tcp, _ := tcpLayer.(*layers.TCP)

		h, l := uint8(tcp.SrcPort>>8), uint8(tcp.SrcPort&0xff)
		srcPort[0] = h
		srcPort[1] = l

		h, l = uint8(tcp.DstPort>>8), uint8(tcp.DstPort&0xff)
		dstPort[0] = h
		dstPort[1] = l
	} else if udpLayer != nil {
		udp, _ := udpLayer.(*layers.UDP)

		h, l := uint8(udp.SrcPort>>8), uint8(udp.SrcPort&0xff)
		srcPort[0] = h
		srcPort[1] = l

		h, l = uint8(udp.DstPort>>8), uint8(udp.DstPort&0xff)
		dstPort[0] = h
		dstPort[1] = l

	} else {
		t.Errorf("Not UDP or TCP")
	}

	return
}

var ipv4TestCases = [][]byte{
	[]byte{0x58, 0x19, 0xF8, 0xF1, 0xE3, 0x48, 0xF0, 0x18, 0x98, 0x28, 0xD, 0x6, 0x8, 0x0, 0x45, 0x0, 0x0, 0x34, 0x0, 0x0, 0x40, 0x0, 0x40, 0x6, 0x8D, 0x7C, 0xA, 0x0, 0x0, 0x7B, 0x23, 0xAE, 0x7F, 0x1F, 0xD4, 0xB0, 0x1, 0xBB, 0x61, 0x47, 0x4, 0x76, 0x7C, 0x4E, 0x7E, 0x73, 0x80, 0x10, 0x7, 0xFA, 0xFA, 0xAA, 0x0, 0x0, 0x1, 0x1, 0x8, 0xA, 0x3D, 0x8C, 0x33, 0xA7, 0xF1, 0x35, 0x2D, 0x7C},
	[]byte{0x1, 0x0, 0x5E, 0x0, 0x0, 0xFB, 0xEC, 0x2C, 0xE2, 0x99, 0x32, 0x82, 0x8, 0x0, 0x45, 0x0, 0x1, 0x2C, 0x30, 0x54, 0x0, 0x0, 0xFF, 0x11, 0x9F, 0x5C, 0xA, 0x0, 0x0, 0x15, 0xE0, 0x0, 0x0, 0xFB, 0x14, 0xE9, 0x14, 0xE9, 0x1, 0x18, 0xFE, 0x47, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6, 0x0, 0x4, 0x0, 0x0, 0x0, 0x1, 0xF, 0x5F, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x6E, 0x69, 0x6F, 0x6E, 0x2D, 0x6C, 0x69, 0x6E, 0x6B, 0x4, 0x5F, 0x74, 0x63, 0x70, 0x5, 0x6C, 0x6F, 0x63, 0x61, 0x6C, 0x0, 0x0, 0xC, 0x0, 0x1, 0x4, 0x5F, 0x68, 0x61, 0x70, 0xC0, 0x1C, 0x0, 0xC, 0x0, 0x1, 0x8, 0x5F, 0x68, 0x6F, 0x6D, 0x65, 0x6B, 0x69, 0x74, 0xC0, 0x1C, 0x0, 0xC, 0x0, 0x1, 0x8, 0x5F, 0x61, 0x69, 0x72, 0x70, 0x6C, 0x61, 0x79, 0xC0, 0x1C, 0x0, 0xC, 0x0, 0x1, 0x5, 0x5F, 0x72, 0x61, 0x6F, 0x70, 0xC0, 0x1C, 0x0, 0xC, 0x0, 0x1, 0xC, 0x5F, 0x73, 0x6C, 0x65, 0x65, 0x70, 0x2D, 0x70, 0x72, 0x6F, 0x78, 0x79, 0x4, 0x5F, 0x75, 0x64, 0x70, 0xC0, 0x21, 0x0, 0xC, 0x0, 0x1, 0xC0, 0xC, 0x0, 0xC, 0x0, 0x1, 0x0, 0x0, 0x11, 0x91, 0x0, 0x13, 0x10, 0x4C, 0x61, 0x63, 0x68, 0x6C, 0x61, 0x6E, 0xE2, 0x80, 0x99, 0x73, 0x20, 0x69, 0x50, 0x61, 0x64, 0xC0, 0xC, 0xC0, 0xC, 0x0, 0xC, 0x0, 0x1, 0x0, 0x0, 0x11, 0x91, 0x0, 0x18, 0x15, 0x4D, 0x61, 0x72, 0x69, 0x65, 0xE2, 0x80, 0x99, 0x73, 0x20, 0x4D, 0x61, 0x63, 0x42, 0x6F, 0x6F, 0x6B, 0x20, 0x50, 0x72, 0x6F, 0xC0, 0xC, 0xC0, 0xC, 0x0, 0xC, 0x0, 0x1, 0x0, 0x0, 0x11, 0x91, 0x0, 0x7, 0x4, 0x61, 0x72, 0x65, 0x73, 0xC0, 0xC, 0xC0, 0x2C, 0x0, 0xC, 0x0, 0x1, 0x0, 0x0, 0x11, 0x91, 0x0, 0x18, 0x15, 0x4C, 0x69, 0x67, 0x68, 0x74, 0x20, 0x50, 0x61, 0x6E, 0x65, 0x6C, 0x73, 0x20, 0x35, 0x36, 0x3A, 0x41, 0x36, 0x3A, 0x36, 0x30, 0xC0, 0x2C, 0x0, 0x0, 0x29, 0x5, 0xA0, 0x0, 0x0, 0x11, 0x94, 0x0, 0x12, 0x0, 0x4, 0x0, 0xE, 0x0, 0x8D, 0xEE, 0x2C, 0xE2, 0x99, 0x32, 0x82, 0xEC, 0x2C, 0xE2, 0x99, 0x32, 0x82},
	[]byte{0xF0, 0x18, 0x98, 0x28, 0xD, 0x6, 0x58, 0x19, 0xF8, 0xF1, 0xE3, 0x48, 0x8, 0x0, 0x45, 0x0, 0x0, 0x53, 0x8C, 0x42, 0x0, 0x0, 0x7A, 0x6, 0xA5, 0xFE, 0x23, 0xBA, 0xE0, 0x2F, 0xA, 0x0, 0x0, 0x7B, 0x1, 0xBB, 0xD4, 0xB4, 0x33, 0x5E, 0x6B, 0xDB, 0x34, 0x0, 0x98, 0x49, 0x80, 0x18, 0x0, 0xF5, 0x4D, 0x15, 0x0, 0x0, 0x1, 0x1, 0x8, 0xA, 0x78, 0x32, 0x25, 0x11, 0x3D, 0x8C, 0x2C, 0xC7, 0x17, 0x3, 0x3, 0x0, 0x1A, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x65, 0xC7, 0x19, 0x60, 0xB2, 0x50, 0x60, 0xEB, 0x7B, 0x44, 0xE9, 0xDC, 0xEE, 0xE3, 0xE2, 0x49, 0x16, 0xE7, 0xBD, 0x0, 0x0, 0x1C},
	[]byte{0x44, 0x7, 0xB, 0x2F, 0xBB, 0x52, 0xF0, 0x18, 0x98, 0x28, 0xD, 0x6, 0x8, 0x0, 0x45, 0x0, 0x0, 0x34, 0x0, 0x0, 0x40, 0x0, 0x40, 0x6, 0x25, 0x4E, 0xA, 0x0, 0x0, 0x7B, 0xA, 0x0, 0x0, 0xFC, 0xD4, 0x8C, 0x1F, 0x49, 0x6C, 0x8, 0x56, 0xFC, 0x35, 0x7F, 0x34, 0x3F, 0x80, 0x10, 0x7, 0xFE, 0x7A, 0x62, 0x0, 0x0, 0x1, 0x1, 0x8, 0xA, 0x3D, 0x8C, 0x29, 0x4E, 0x0, 0x36, 0x57, 0x3D},
}

func TestIPv4Packets(t *testing.T) {
	for idx, packet_data := range ipv4TestCases {
		goPacket := createGoPacket(packet_data)
		expEthType, expSrcIP, expDstIP, expSrcPort, expDstPort := getGoPacketValues(goPacket, t)

		got, err := GetEthProtocol(packet_data)
		if err != nil {
			t.Errorf("Testcase %d: ethernet type: %v", idx, err)
		}
		if got != expEthType {
			t.Errorf("Testcase %d: ethernet type: got %v expecting %v", idx, got, expEthType)
		}

		srcIP, dstIP, err := GetSrcDstIP(packet_data[14:])
		if err != nil {
			t.Errorf("Testcase %d: source/dest IP: %v", idx, err)
		}
		if srcIP != expSrcIP {
			t.Errorf("Testcase %d: source IP: got %v expecting %v", idx, srcIP, expSrcIP)
		}
		if dstIP != expDstIP {
			t.Errorf("Testcase %d: dest IP: got %v expecting %v", idx, dstIP, expDstIP)
		}

		srcPort, dstPort, err := GetSrcDstPort(packet_data[14:])
		if err != nil {
			t.Errorf("Testcase %d: source/dest port: %v", idx, err)
		}
		if srcPort != expSrcPort {
			t.Errorf("Testcase %d: source port: got %v expecting %v", idx, srcPort, expSrcPort)
		}
		if dstPort != expDstPort {
			t.Errorf("Testcase %d: dest port: got %v expecting %v", idx, dstPort, expDstPort)
		}
	}
}
