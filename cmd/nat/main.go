package main

import (
	"fmt"
	"nat_project/pkg/nat"
)

/* Driver for NAT Stuff, if needed */

func pp_table(mappings map[nat.IPAddress]*nat.IPAddress) {
	fmt.Println("--------------------------")
	for key, value := range mappings {
		fmt.Printf("%v to %v \n", key, *value)
	}
	fmt.Println("--------------------------")
}

func main() {
	in_to_out_nat := nat.NAT_Table{}
	in_to_out_nat.AddMapping([4]byte{0x01, 0x01, 0x01, 0x01}, [2]byte{0x00, 0x80}, [4]byte{0x02, 0x02, 0x02, 0x02}, [2]byte{0x00, 0x70})
	in_to_out_nat.AddMapping([4]byte{0x01, 0x01, 0x01, 0x01}, [2]byte{0x00, 0x80}, [4]byte{0x02, 0x02, 0x02, 0x02}, [2]byte{0x00, 0x50})
	in_to_out_nat.AddMapping([4]byte{0x03, 0x03, 0x03, 0x03}, [2]byte{0x00, 0x80}, [4]byte{0x04, 0x04, 0x04, 0x04}, [2]byte{0x00, 0x80})
	in_to_out_nat.AddMapping([4]byte{0x03, 0x03, 0x03, 0x03}, [2]byte{0x00, 0x50}, [4]byte{0x04, 0x04, 0x04, 0x04}, [2]byte{0x00, 0x50})

	out_to_in_nat := nat.NAT_Table{}
	out_to_in_nat.AddMapping([4]byte{0x02, 0x02, 0x02, 0x02}, [2]byte{0x00, 0x70}, [4]byte{0x01, 0x01, 0x01, 0x01}, [2]byte{0x00, 0x80})
	out_to_in_nat.AddMapping([4]byte{0x02, 0x02, 0x02, 0x02}, [2]byte{0x00, 0x50}, [4]byte{0x05, 0x05, 0x05, 0x05}, [2]byte{0x00, 0x80})
	out_to_in_nat.AddMapping([4]byte{0x04, 0x04, 0x04, 0x04}, [2]byte{0x00, 0x80}, [4]byte{0x03, 0x03, 0x03, 0x03}, [2]byte{0x00, 0x80})
	out_to_in_nat.AddMapping([4]byte{0x04, 0x04, 0x04, 0x04}, [2]byte{0x00, 0x50}, [4]byte{0x03, 0x03, 0x03, 0x03}, [2]byte{0x00, 0x50})

	pp_table(in_to_out_nat.ListMappings())
	pp_table(out_to_in_nat.ListMappings())

	dstIP, dstPort, err := in_to_out_nat.GetMapping([4]byte{0x01, 0x01, 0x01, 0x01}, [2]byte{0x00, 0x80})
	if err != nil {
		fmt.Println("error")
		return
	}
	fmt.Printf("%v %v \n", dstIP, dstPort)

	srcIP, srcPort, err := out_to_in_nat.GetMapping(dstIP, dstPort)
	if err != nil {
		fmt.Println("error")
		return
	}
	fmt.Printf("%v %v \n", srcIP, srcPort)
}
